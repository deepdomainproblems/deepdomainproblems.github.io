# Coding with AI and Sunk Cost Fallacy

This is my experience and how it has been going with AI. This is intended to help myself and everyone who has questions about whether AI will take over jobs.

Frankly, it doesn't open a debate for me - computing has been taking over jobs for decades, and at the same time created tons of new jobs, where people from core domains even doctors have left their jobs and switched to software - because it pays well.

## The AI Consultant Experience

Coding with AI has become an unavoidable part of my daily job - of course who wouldn't want a consultant intelligence at keystrokes away. AI subscription prices vary widely - some are free with basic features, while paid tiers range from $10-50+ monthly depending on capabilities and usage limits. That's why I have subscriptions to all the popular intelligent beings - Claude, Copilot, ChatGPT - and Deepseek, Cursor, Cline on Open Router. Sometimes I feel it's a good distraction from solving the problem myself, and sometimes it feels like it merely satisfies my "fear of missing out" on some amazing solution this intelligent being might spell out (the tone of sarcasm is real).

As I have been doing that, I slowly began to understand that - though you can consult with AI on everything you are working on, it's like quicksand - it produces an overwhelming amount of content in seconds, be it amount of code (I can't type that fast) or amount of knowledge. So it gives a feeling that one must be a fool to not use it, and rely on their own intelligence.

## The FOMO and Sunk Cost Problem

So it's FOMO which first pulls you into its world, and once you start solving with AI, the next step is continuously investing into it to get it to solve the problem. This is actually the sunk cost fallacy - continuing a behavior based on previously invested resources. If you don't realize it's not going to solve the problem - it's many hours gone.

And let's say you do rely on it from the first go, it's fine as long as it does things right, but if it makes a mistake (which it does more often than not - first because it's not even equipped with all the knowledge and it's outdated), it takes hours to debug. Many times I just gave up.

When you start solving with AI, you need to first hold your breath and believe that it might not be capable of solving it today. And in some odd weird scenario, you are wiser than AI to know when to stop going down the black hole. (The only savior is AI hitting the limit). But if you use AI via APIs like Cline, you won't hit the limit either. Every problem is not AI's cup of tea (at least not in the way you think).

## The Real Power of AI

The real power of AI is not yet in just these names but in "prompt engineering" - that's why files like cursor rules, copilot instructions exist. The next rise is in "taming" AI (but I would just continue calling it taming LLMs). Attributing every failure and success to AI entirely seems unfair - LLMs work in their own way, and let them.

### Would I continue using LLMs? 

Hell yeah. It's a continuous learning process - to use AI first of all you need to understand yourself and how you think. You need to give it the bits and pieces of the puzzle you want it to solve, make it solve those bits.

For example - if I want a class or function which is supposed to perform depth first search on my data structure, I do need to take time to solve it myself - think of it as "setting the direction" - and if you don't set it, it will set and take you down that hole. It doesn't matter if you have time - but when you don't have time, it's better to be careful. Once you set the direction, you take it down the path you want, not in the path it takes you. Make it generate those things which it can do at great pace. 

Continuing the example - it can write the above code faster than me and less buggy than me, only if I am patient enough to drive it. It's traditionally called the primary-replica model (formerly master-slave), and in this case the secondary instance doesn't carry the negative connotation. Moreover, you would hate if your database doesn't have replicas or multiple replicas for redundancy and performance.
